<!DOCTYPE html>
<html style="height: 100%" lang="en">

<head>
    <meta charset="utf-8">
    <title>{{.Title}}</title>
</head>

<body style="height: 100%; margin: 0">

{{if eq (len .DataRows) 0 }}
{{if eq (len .CsvData) 0 }}
<div id="selectCSVFile">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/ratchet/2.0.2/css/ratchet.css" rel="stylesheet"/>
    <label for="myFile" class="btn btn-primary btn-block btn-outlined">导入 CSV 数据文件</label>
    <input id="myFile" style="visibility:hidden;" type="file">
</div>
{{end}}
{{end}}

<div id="container" style="height: 100%"></div>

<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/echarts@5.3.1/dist/echarts.min.js"></script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/echarts@5.3.1/dist/extension/dataTool.min.js"></script>

<script>
    function tryParseInt(val) {
        let v = parseInt(val);
        return isNaN(v) ? val : v;
    }

    function getDataPointsFromCSV(pointsData, csv, extraFn) {
        let dataPoints = pointsData || [];
        let csvLines = csv.split(/\r?\n+/);
        let headerNames = null;

        for (let i = 0; i < csvLines.length; i++) {
            if (csvLines[i].length === 0) {
                continue
            }

            let points = csvLines[i].split(",");
            if (headerNames == null) {
                headerNames = points;
                continue
            }

            let p = {}
            for (let j = 0; j < headerNames.length; j++) {
                p[headerNames[j]] = points[j] === 'NULL' ? 0 : points[j];
            }

            if (extraFn) {
                p = extraFn(p);
            }
            dataPoints.push(p);
        }

        return dataPoints;
    }

    /**
     * Format bytes as human-readable text.
     *
     * @param bytes Number of bytes.
     * @param si True to use metric (SI) units, aka powers of 1000. False to use
     *           binary (IEC), aka powers of 1024.
     * @param dp Number of decimal places to display.
     *
     * @return Formatted string.
     */
    function humanSize(bytes, si = false, dp = 1) {
        const thresh = si ? 1000 : 1024;

        if (Math.abs(bytes) < thresh) {
            return bytes + ' B';
        }

        const units = si
            ? ['kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']
            : ['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'];
        let u = -1;
        const r = 10 ^ dp;

        do {
            bytes /= thresh;
            ++u;
        } while (
            Math.round(Math.abs(bytes) * r) / r >= thresh &&
            u < units.length - 1
            );

        return bytes.toFixed(dp) + ' ' + units[u];
    }

    function convertDataPoint (v) {
        {{range .AfterCsvLoad}}
        {{.}}
        {{end}}
        return v
    }

    {{if eq (len .DataRows) 0 }}
    {{if eq (len .CsvData) 0 }}
    document.getElementById("myFile").addEventListener("change", function () {
        if (this.files && this.files[0]) {
            const reader = new FileReader();
            reader.addEventListener('load', function (e) {
                echartDataLoad(getDataPointsFromCSV(null, e.target.result), convertDataPoint);
                let el = document.getElementById('selectCSVFile');
                el.style.visibility = "hidden";
                el.style.height = '0px';
            });

            // reader.readAsBinaryString(myFile);
            reader.readAsText(this.files[0]);
        }
    });
    {{end}}
    {{end}}


    let humanNum = function (value) {
        let k = 10000, sizes = ['', '万', '亿', '万亿'], i;
        if (value < k) {
            return Number(value).toFixed(2);
        }

        i = Math.floor(Math.log(value) / Math.log(k));
        return (value / Math.pow(k, i)).toFixed(2) + sizes[i];
    };


    let tooltipFormat = function (params) {
        // console.log(JSON.stringify(params));
        let res = {{.Tooltip.Prefix}} + '<p>';
        for (let i = 0; i < params.length; i++) {
            const p = params[i];
            const v = p.data;
            {{range .Series}}
            if (p.seriesName === '{{.Name}}') {
                res += '<p>' + p.seriesName + ': ' + {{.Tooltip}}
            }
            {{end}}
        }
        return res;
    }

    let echartDataLoad = function (dataPoints, extraFn) {
        if (extraFn) {
            for (let i = 0; i < dataPoints.length; i++) {
                dataPoints[i] = extraFn(dataPoints[i])
            }
        }

        for (let i = 0; i < dataPoints.length; i++) {
            dataPoints[i]._seq = (i+1)
        }

        let option = {
            legend: {selected: {
                {{ $len := len .Series }}
                {{range $i, $v := .Series}}
                    '{{.Name}}': {{.Selected | ToString}} {{if lt $i $len}},{{end}}
                {{end}}
            }
            },
            dataset: {source: dataPoints},
            xAxis: {type: 'category'},
            yAxis: {gridIndex: 0},
            series: [
                {{ $len := len .Series }}
                {{range $i, $v :=.Series}}
                {name: '{{.Name}}', type: 'line', smooth: true, emphasis: {focus: 'series'},encode: {x: '{{.X}}', y: '{{.Y}}'}}{{if lt $i $len}},{{end}}
                {{end}}
            ],
            dataZoom: [
                {type: 'slider', show: true, xAxisIndex: [0, 1]},
                {type: 'inside', xAxisIndex: [0, 1]}],
            tooltip: {
                trigger: 'axis', axisPointer: {type: 'cross'}, formatter: tooltipFormat
            },
            toolbox: {
                feature: {
                    dataView: {show: true, readOnly: false},
                    magicType: {show: true, type: ['line', 'bar']},
                    dataZoom: {show: true},
                    restore: {show: true},
                    saveAsImage: {show: true}
                }
            },
        };

        const dom = document.getElementById("container");
        const myChart = echarts.init(dom);

        myChart.on('updateAxisPointer', function (event) {
            const xAxisInfo = event.axesInfo[0];
            if (xAxisInfo) {
                const dimension = xAxisInfo.value + 1;
                myChart.setOption({
                    series: {
                        id: 'pie', label: {formatter: '{b}: {@[' + dimension + ']} ({d}%)'},
                        encode: {value: dimension, tooltip: dimension}
                    }
                });
            }
        });
        myChart.setOption(option);

        window.onresize = function () {
            myChart.resize();
        }
    }

    document.addEventListener('readystatechange', function () {
        let pointsData = []
        {{if gt (len .DataRows) 0 }}
        pointsData = {{.DataRows | ToString}}
        {{end}}
        {{if gt (len .CsvData) 0 }}
        getDataPointsFromCSV(pointsData, '{{.CsvData | JoinLines}}');
        {{end}}

        if (pointsData.length > 0) {
            echartDataLoad(pointsData, convertDataPoint)
        }
    });
</script>
</body>

</html>